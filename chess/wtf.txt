Chess.rb
c = Chess.new
self.board = Board.new
self.players = [HumanPlayer.new(:white), HumanPlayer.new(:black)]
c.play
def play
  #get player
  player.turn
def turn(board)
  def take_input(board)
  def get_valid_move(board)
    if valid? and piece.exist? and piece.your_color?
      piece.available_moves
#############Check User Input ####################
def available_moves(board, &blk)
blk = Proc.new { |move| move_possible?(move, board) }
moves = plausible_moves(board)
# get plausible_moves
moves.select!(&blk)
######### Filter Plausible Moves ################
SubPiece:: def move_possible?(dest, board)
return false unless super(dest, board)
# removes moves that are not in the bounds of the board
# disallows the pieces to take their own dudes
# removes moves that would put the player into check
return false if moved_into_check?(dest, board)
##################################################
###### make suer we don't check ourselves ########
##################################################
def moved_into_check?(dest, board)
# move piece to new location
# store the 'dead piece'
# store king
  # find king
# loop through all pieces types
######### check if any piece can take king  ######
# hypothetically places each piece on the board where the king is
pieces.each do |piece| (Pawn.new(color,k_pos))
  #
moves = piece.available_moves(board, &no_check_proc)
### find which positions that can check king #####
def available_moves(board, &blk)
blk = Proc.new { |move| ignore_check_move_possible?(move, board) }
moves = plausible_moves(board)
# get plausible_moves
moves.select!(&blk)
####### filter plausible moves ###################
SubPiece:: def ignore_check_move_possible?(dest, board)
return false unless super(dest, board)
# removes moves that are not in the bounds of the board
# disallows the pieces to take their own dudes



